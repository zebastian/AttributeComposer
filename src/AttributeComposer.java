//+============================================================================
// $Source: /users/chaize/newsvn/cvsroot/Calculation/AttributeComposer/src/AttributeComposer.java,v $
//
// project :     Tango Device Server
//
// Description: java source code for the AttributeComposer class and its commands.
//              This class is derived from DeviceImpl class.
//              It represents the CORBA servant obbject which
//              will be accessed from the network. All commands which
//              can be executed on the StateComposer are implemented
//              in this file.
//
// $Author: ounsy $
//
// $Revision: 1.25 $
//
// $Log: not supported by cvs2svn $
// Revision 1.24  2007/03/01 15:57:55  ounsy
// changed imports
//
// Revision 1.23  2007/02/22 15:51:42  katyho
// Fixe Bug of unKnowned attributes
//
// Revision 1.22  2007/02/22 15:03:35  ounsy
// corected a bug : attributeResultReport didn't work for KO attributes on startup
//
// Revision 1.21  2007/02/22 15:01:33  ounsy
// corected a bug : attributeResultReport didn't work for KO attributes on startup
//
// Revision 1.20  2007/02/22 10:14:10  ounsy
// specified in their declaration what kind of Threads StateReader etc.. are
//
// Revision 1.19  2007/02/21 15:11:41  katyho
// Fixe bug 3779 and make booleanResult writable
//
// Revision 1.18  2007/02/20 11:19:17  ounsy
// the value reading is now done in a separate thread
//
// Revision 1.17  2007/02/20 09:33:42  ounsy
// corrected a bug in read_attr_hardware
//
// Revision 1.16  2007/02/16 11:19:25  katyho
// Remove warning for the AttributeComposer.java
//
// Revision 1.15  2007/02/16 10:28:43  katyho
// Merging groups
//
// Revision 1.14.2.6  2007/02/15 13:41:05  ounsy
// uses the new Group APIs naming:
// interfaces drop the "I" prefix in their names
//
// Revision 1.14.2.5  2007/02/12 14:59:32  ounsy
// uses the latest version of the group APIs
//
// Revision 1.14.2.4  2007/02/09 16:45:12  ounsy
// utilise les nouvelles apis de groupe post-refactoring
//
// Revision 1.14.2.3  2007/01/31 15:22:49  ounsy
// -made commands synchronized
// -init_device is now called synchronously
//
// Revision 1.14.2.2  2007/01/29 14:56:32  ounsy
// now using the groupactions APIs
//
// Revision 1.14  2006/12/21 11:45:44  katyho
// Clear all the tables
//
// Revision 1.7  2006/05/02 09:56:14  katyho
// Remove all the command in the clear Method
//
// Revision 1.2  2006/03/09 11:17:26  katyho
// Modify the GetTangoState command
//
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-============================================================================
//
//          This file is generated by POGO
//  (Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//============================================================================

package AttributeComposer;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;

import org.omg.CORBA.SystemException;
import org.omg.CORBA.UserException;

import fr.esrf.Tango.AttrQuality;
import fr.esrf.Tango.DevFailed;
import fr.esrf.Tango.DevState;
import fr.esrf.TangoApi.Database;
import fr.esrf.TangoApi.DbDatum;
import fr.esrf.TangoApi.DeviceProxy;
import fr.esrf.TangoDs.Attribute;
import fr.esrf.TangoDs.DeviceClass;
import fr.esrf.TangoDs.DeviceImpl;
import fr.esrf.TangoDs.Except;
import fr.esrf.TangoDs.TangoConst;
import fr.esrf.TangoDs.Util;
import fr.esrf.TangoDs.WAttribute;
import fr.soleil.actiongroup.attributecomposer.AttributeComposerFacade;
import fr.soleil.actiongroup.attributecomposer.AttributeComposerFacadeImpl;
import fr.soleil.actiongroup.collectiveaction.components.tangowrapping.AttrQualityWrapper;
import fr.soleil.actiongroup.collectiveaction.components.tangowrapping.target.Target;
import fr.soleil.actiongroup.collectiveaction.components.tangowrapping.target.TargetFactory;
import fr.soleil.actiongroup.collectiveaction.onattributes.write.attributeinfomodifier.AttributeInfoModifierFactory;
import fr.soleil.device.utils.QualityUtilities;
import fr.soleil.device.utils.StateUtilities;
import fr.soleil.device.utils.TangoExceptionUtilities;

public class AttributeComposer extends DeviceImpl  implements TangoConst
{
    protected int state;
    
    //--------- Start of attributes data members ----------
    protected double attr_spectrumResult_read[] = new double[10000];
    protected short attr_booleanSpectrum_read[] = new short[10000];
    protected String attr_attributesQualityList_read[] = new String[1000];
    protected short attr_attributesNumberPriorityList_read[] = new short[1000];
    protected String attr_attributesResultReport_read[] = new String[10000];
    protected boolean attr_booleanResult = false;
    
    private AttributeComposerFacade facade;
    //  --------- End of attributes data members ----------

    //--------- Start of properties data members ----------
    /**
     * The list of attribute name used to composed the resum state and the spectrum result.
     */
    String attributeNameList[];
    /**
    * The priority number of a quality (the greater is the most important is ex: 5
    * for ALARM) Call GetTangoQuality to know the list of the Tango Quality order.
    */
    String priorityList[];
    /**
     * The logical gates to apply on the list of attribute.
     */
    String logicalBoolean;
    
    //--------- End of properties data members ----------
    
    //  Add your own data members here
    //--------------------------------------
    /*
     * The supported logical gates
     */
    private static final String NONE = "NONE";
    private static final String OR = "OR";
    private static final String AND = "AND";
    private static final String XOR = "XOR";
    private static final String logicalChoices[] = {NONE, OR, AND, XOR};
    
    /*
     * The table of priority <AttrQuality, Priority>
     */
    private Map<AttrQuality, Integer> m_priorityTable = new Hashtable<AttrQuality, Integer>();   
    /*
     * The table of the quality and their associated device State 
     */
    private Map<AttrQuality, DevState> m_qualityStateTable = new Hashtable<AttrQuality, DevState>();
    /*
     * The table of the attribute name and their associated qualities <attributeName, AttrQuality>
     */
    private Map<String, AttrQualityWrapper> m_attributeQualityTable = new Hashtable<String, AttrQualityWrapper>();
    /*
     * The table of the attribute name and their associated read values <attributeName, values>
     */
    private Map<String, Double> m_attributeValueTable = new Hashtable<String, Double>();
    /*
     * The table of the attribute name and their associated message result <attributeName, message report>
     * the messages are generated during the connexion, read or write instruction
     */
    private Map<String, String> m_attributeResultReportTable = new Hashtable<String, String>();
    
    private Vector<Boolean> m_booleanLogicalVector = new Vector<Boolean>();
    
    private String m_sentProperty = "";
    /*
     * When the device is well initialized = true for the quality
     */
    private boolean m_initializedQuality = false;
    /*
     * The thread that Update the State of the device
     */
    private StateReader m_StateReader = null;
    /*
     * The thread that Update the State of the device
     */
    private StateUpdater m_StateUpdater = null;
    /*
     * The thread that Update the values of the spectrumResult
     */
    private ValueReader m_ValueReader = null;
    /*
     * The thread that Update the values of the spectrumResult
     */
    private ValueUpdater m_ValueUpdater = null;
    /**
     *  SimpleDateFormat to timeStamp the error messages
     */
    public static final SimpleDateFormat m_insertformat  = new SimpleDateFormat ("dd-MM-yyyy HH:mm:ss");
    

//=========================================================
/**
 * Constructor for simulated Time Device Server.
 * 
 * @param cl
 *            The DeviceClass object
 * @param s
 *            The Device name.
 */
//=========================================================
 AttributeComposer(DeviceClass cl, String s) throws DevFailed
 {
     super(cl, s);
     //Build the m_qualityState table
     m_qualityStateTable.put(AttrQuality.ATTR_CHANGING, DevState.MOVING);
     m_qualityStateTable.put(AttrQuality.ATTR_ALARM, DevState.ALARM);
     m_qualityStateTable.put(AttrQuality.ATTR_WARNING, DevState.ALARM);
     m_qualityStateTable.put(AttrQuality.ATTR_INVALID, DevState.FAULT);
     m_qualityStateTable.put(AttrQuality.ATTR_VALID, DevState.ON);
     
     //Initialize a default priority table if the PriorityList properties is not defined
     // Greater the priority number is, greater the priority is important
     m_priorityTable.put(AttrQuality.ATTR_VALID, new Integer(2));
     m_priorityTable.put(AttrQuality.ATTR_CHANGING, new Integer(0));
     m_priorityTable.put(AttrQuality.ATTR_WARNING, new Integer(3));
     m_priorityTable.put(AttrQuality.ATTR_ALARM, new Integer(3));
     m_priorityTable.put(AttrQuality.ATTR_INVALID, new Integer(4));
     
     //build the associated PriorityList property
     //Syntax "Quality name","PriorityNumber"
     priorityList = new String[m_priorityTable.size()];
     Iterator enumeration  = m_priorityTable.keySet().iterator();
     int tmpIndex = 0;
     while (enumeration.hasNext())
     {
         AttrQuality key = (AttrQuality) enumeration.next();
         priorityList[tmpIndex]= QualityUtilities.getNameForQuality(key) + "," + m_priorityTable.get(key);
         tmpIndex++;
     }
     init_device();
 }
 
 //=========================================================
 /**
  * Constructor for simulated Time Device Server.
  * 
  * @param cl
  *            The DeviceClass object
  * @param s
  *            The Device name.
  * @param d
  *            Device description.
  */
 //=========================================================
 AttributeComposer(DeviceClass cl, String s, String d) throws DevFailed
 {
     super(cl, s, d);
     init_device();
 }
 
 //=========================================================
 /**
  * Initialize the device.
  */
 //=========================================================
 public void init_device() throws DevFailed
 {
     System.out.println("AttributeComposer() create " + device_name);
     //Clear all the commands and empty the tables
     clearAll();
     set_state(DevState.STANDBY);
     // Start the initalisation in a Thread in order to avoid the timeout problem
     (new Thread()
     {
         public void run() {
             try
             {
                 get_device_property();
                 
                 //get the custom priority
                 getCustomPriorityList();
                
                 //Creation of device proxy group
                 groupCreation();
             }
             catch(Exception exception)
             {
                 m_initializedQuality = false;
                 set_state(DevState.FAULT);
                 set_status("Device is not initialzed properly :\n" + TangoExceptionUtilities.getMessage(exception));
             }
         }//End run
     //}).start();
     }).run();
     
     //testReadTimes ();
 }

 /*
  * Clear all 
  */
 public void clearAll()
 {
     m_attributeValueTable.clear();
     m_attributeQualityTable.clear();
     //m_attributeGroupTable.clear();
     m_attributeResultReportTable.clear();
     //m_QualityReader = null;
     //m_ValueReader = null;
     m_StateUpdater = null;
     m_ValueUpdater = null;     
     //m_sentValue = Double.NaN;
     m_sentProperty = "";
     m_initializedQuality = false;
     //m_initializedValue = false;
 }
 
 /**
  * Get the custom priority list
  */
 private void getCustomPriorityList()
 {
     //Set the non defined state in the property at 0 priority
     //Enumeration of existing state
     Enumeration keys = QualityUtilities.getQualityTable().keys();
     Integer tmpPriority = new Integer(0);
     while (keys.hasMoreElements()) 
     {
         AttrQuality key = (AttrQuality) keys.nextElement();
         m_priorityTable.put(key, tmpPriority);            
     }
     
     //Get the custom priority
     for (int i = 0; i < priorityList.length; i++)
     {
         //System.out.println("priorityList["+ i + "]=" + priorityList[i]);
         //Syntax "Quality","PriorityNumber"
         //So count the token separated by ","
         StringTokenizer token = new StringTokenizer(priorityList[i].trim(), ",");
         if (token.countTokens() == 2)
         {
             //To avoid the the pb of case
             String tmpQualityName = token.nextToken().trim().toUpperCase();
             //If the custom state exist
             if (QualityUtilities.isQualityExist(tmpQualityName))
             {
                 //The default proprity
                 try
                 {
                     tmpPriority = Integer.valueOf(token.nextToken().trim());
                 }
                 catch (NumberFormatException e){}
                 
                 //System.out.println("Quality=" + tmpQualityName);
                 //System.out.println("Priority=" + tmpPriority);
                 m_priorityTable.put(QualityUtilities.getQualityForName(tmpQualityName), tmpPriority);
             }
         }
     }
 }
 
 /**
  * Creation of the group of devices
 */
 private void groupCreation() throws Exception
 {
     //If no property defined the devices is in STANDBY
     if (attributeNameList == null || attributeNameList.length == 0 || attributeNameList[0].trim().equals(""))
     {
         m_initializedQuality = false;
         set_state(DevState.STANDBY);
         set_status("No attribute defined");
         attr_spectrumResult_read = new double[0];
         attr_booleanSpectrum_read = new short[0];
         attr_attributesQualityList_read = new String[0];
         attr_attributesNumberPriorityList_read = new short[0];
         return;
     }
     
     //Initialize all the attributes
     attr_spectrumResult_read = new double[attributeNameList.length];
     attr_booleanSpectrum_read = new short[attributeNameList.length];
     attr_attributesQualityList_read = new String[attributeNameList.length];
     attr_attributesNumberPriorityList_read = new short[attributeNameList.length];
     for(int i = 0; i < attr_spectrumResult_read.length; i++)
     {
         attr_spectrumResult_read[i] = Double.NaN;
         attr_booleanSpectrum_read[i] = 0;
         attr_attributesQualityList_read[i] = QualityUtilities.getNameForQuality(AttrQuality.ATTR_INVALID) + "-" + attributeNameList[i];
         attr_attributesNumberPriorityList_read[i] = ((Integer)m_priorityTable.get(AttrQuality.ATTR_INVALID)).shortValue();
     }

     //First remove the double entry of proxy thanks to a Vector
     
     Hashtable<String, Collection<String>> deviceToAttributes = new Hashtable<String, Collection<String>> ();
     
     for(int i = 0; i < attributeNameList.length; i++)
     {
         String tmpFullAttributeName = attributeNameList[i].trim();
         String tmpAttributeName = "";
         String tmpDeviceName = "";
         //attribute name = //TANGO:HOST/FAMILY/DOMAIN/MEMBER/ATTRIBUTENAME
         //So extract the last index of /
         int pos = tmpFullAttributeName.lastIndexOf("/");
         if(pos != -1)
         {
             tmpDeviceName = tmpFullAttributeName.substring(0, pos);
             tmpAttributeName = tmpFullAttributeName.substring(pos + 1, tmpFullAttributeName.length());
         }
         else
         {
             m_initializedQuality = false;
             set_state(DevState.FAULT);
             set_status("See the attributesResultReport attribute and make an Init Command");
             m_attributeResultReportTable.put(tmpFullAttributeName,m_insertformat.format(new Date()) + " : is not an attribute please update the AttributeNameList property");
             return;
         }
         try
         {
             //System.out.println( "CLA/groupCreation/tmpDeviceName|"+tmpDeviceName);
             Collection<String> attributesForThisDevice = deviceToAttributes.get( tmpDeviceName );
             if ( attributesForThisDevice == null )
             {
                 attributesForThisDevice = new Vector<String> ();
                 deviceToAttributes.put ( tmpDeviceName, attributesForThisDevice );
             }
             //System.out.println( "CLA/groupCreation/tmpAttributeName|"+tmpAttributeName+"|tmpDeviceName|"+tmpDeviceName);
             attributesForThisDevice.add ( tmpAttributeName );
         }
         catch (Exception e)
         {
             m_initializedQuality = false;
             set_state(DevState.FAULT);
             set_status("See the attributesResultReport attribute and make an Init Command");
             m_attributeResultReportTable.put(tmpFullAttributeName,m_insertformat.format(new Date()) + " : Connexion error relaunch it and make an Init Command");
         }
     }
     
     //Arrived here the device is initiazed correctly 
     m_initializedQuality = true;
     //m_initializedValue = true;
     
     int numberOfProxies = deviceToAttributes.size();
     Iterator<String> it = deviceToAttributes.keySet().iterator ();
     Target [] proxies = new Target [ numberOfProxies  ];
     String[][] attributes = new String[numberOfProxies][];
     
     int i = 0;
     while ( it.hasNext () )
     {
         String nextDevice = it.next ();
         //System.out.println( "CLA/nextDevice|"+nextDevice);
         proxies [ i ] = TargetFactory.getTarget ( new DeviceProxy ( nextDevice ) );
         
         Collection<String> attributesForThisDevice = deviceToAttributes.get( nextDevice );
         Iterator<String> it2 = attributesForThisDevice.iterator ();
         attributes [ i ] = new String [ attributesForThisDevice.size () ];
         int j = 0;
         while ( it2.hasNext () )
         {
             String nextAttribute = it2.next ();
             //System.out.println( "  CLA/nextAttribute|"+nextAttribute);
             attributes [i][j] = nextAttribute;
             j++;
         }
         
         i++;
     }
     
     facade = new AttributeComposerFacadeImpl ( proxies , attributes );
 }
 
 /*
  * Return the index of a given attribute 
  */
 private int get_index_for_attribute(String aAttributeName)
 {
     int tmpIndex = -1;
     
     if(aAttributeName.trim().equals(""))
         return tmpIndex;
     
     for(int i = 0; i < attributeNameList.length; i++)
         if(attributeNameList[i].trim().equalsIgnoreCase(aAttributeName))
             return i;

     return tmpIndex;
 }
 
 /*
  * Return the result of the logical gates on a given vecto 
  */
 private boolean apply_logical_gate(Vector<Boolean> aBooleanVector)
 {
     if(logicalBoolean.equals(NONE))
         return false;
     
     boolean result = false;
     if(aBooleanVector.size() == 1)
     {
         if(logicalBoolean.equalsIgnoreCase(XOR))
             result = true;
         else
             result = ((Boolean)m_booleanLogicalVector.elements().nextElement()).booleanValue();
     }
     if(aBooleanVector.size() == 2)
     {
         if(logicalBoolean.equalsIgnoreCase(XOR))
             result = false;
         else if(logicalBoolean.equalsIgnoreCase(OR))
             result = true;
         else
             result = false;
     }
     return result;
 }

 //===================================================================
 /**
  * Read the device properties from database.
  */
 //===================================================================
 public void get_device_property() throws DevFailed
 {
     if(!Util._UseDb)
         return;
     String propnames[] = 
     {
         "AttributeNameList",
         "PriorityList",
         "LogicalBoolean"
     };
     
     DbDatum dev_prop[] = get_db_device().get_property(propnames);
     int i = -1;
     
     // Extract AttributeNameList value
     if(!dev_prop[++i].is_empty())
         attributeNameList = dev_prop[i].extractStringArray();
     else
     {
         DbDatum dev_prop1 = get_db_device().get_property("AttributeNameList");
         attributeNameList = new String[] {""};
         dev_prop1.insert(attributeNameList);
         get_db_device().put_property(new DbDatum[] { dev_prop1 });
     }
     
     //Extract PriorityList value
     if(!dev_prop[++i].is_empty())
         priorityList = dev_prop[i].extractStringArray();
     else
     {
         DbDatum dev_prop1 = get_db_device().get_property("PriorityList");
         dev_prop1.insert(priorityList);
         get_db_device().put_property(new DbDatum[] {dev_prop1});
     } 
     
     //Extract LogicalBoolean value
     if(!dev_prop[++i].is_empty())
     {
         logicalBoolean = dev_prop[i].extractString();
         if(logicalBoolean.trim().equals(""))
         {
             logicalBoolean = NONE;
             DbDatum dev_prop1 = get_db_device().get_property("LogicalBoolean");
             dev_prop1.insert(logicalBoolean);
             get_db_device().put_property(new DbDatum[] {dev_prop1});
         }
     }
     else
     {
         DbDatum dev_prop1 = get_db_device().get_property("LogicalBoolean");
         logicalBoolean = NONE;
         dev_prop1.insert(logicalBoolean);
         get_db_device().put_property(new DbDatum[] {dev_prop1});
     }
 }

//=========================================================
 /**
  * Method always executed before command execution.
  */
 //=========================================================
 public void always_executed_hook()
 {
     get_logger().info("In always_executed_hook method()");
     try
     {
         if(m_StateReader == null || !m_StateReader.isAlive())
         {
             m_StateReader = new StateReader();
             m_StateReader.start();
         }
         
         if(m_StateUpdater == null || !m_StateUpdater.isAlive())
         {
             m_StateUpdater = new StateUpdater();
             m_StateUpdater.start();
         }
     }
     catch (Exception e)
     {
         m_initializedQuality = false;
         set_state(DevState.FAULT);
         set_status(m_insertformat.format(new Date()) + " : Fatal Error Execute and Init Command \n" + TangoExceptionUtilities.getMessage(e));
     }
  }
 /*
 private void traceAttributeToQualityTable ( String comment ) 
 {
     Iterator it= m_attributeQualityTable.keySet().iterator();
     System.out.println ( "traceAttributeToQualityTable "+comment + " VVVVVVV" );
     while ( it.hasNext () )
     {
         String nextAttr = (String) it.next ();
         AttrQuality nextVal = m_attributeQualityTable.get ( nextAttr ).getAttrQuality();
         System.out.println ( "      nextAttr|"+nextAttr+"|nextQuality|"+QualityUtilities.getNameForQuality(nextVal) );
     }
     System.out.println ( "traceAttributeToQualityTable "+comment + " ^^^^^^^^" );
 }
 */
 //===================================================================
 /**
  * Method called by the read_attributes CORBA operation to read device
  * hardware
  * 
  * @param attr_list
  *            Vector of index in the attribute vector of attribute to be
  *            read
  */
 //===================================================================
 public void read_attr_hardware(Vector attr_list)
 {
     get_logger().info("In read_attr_hardware for " + attr_list.size() + " attribute(s)");
     if ( facade == null || ! this.m_initializedQuality )
     {
         return;
     }
     
     try
     {
         if(m_ValueReader == null || !m_ValueReader.isAlive())
         {
             m_ValueReader = new ValueReader();
             m_ValueReader.start();
         }

         if(m_ValueUpdater == null || !m_ValueUpdater.isAlive())
         {
             m_ValueUpdater = new ValueUpdater();
             m_ValueUpdater.start();
         }
     }
     catch (Exception e)
     {
         m_initializedQuality = false;
         set_state(DevState.FAULT);
         set_status(m_insertformat.format(new Date()) + " : Fatal Error Execute and Init Command \n" + TangoExceptionUtilities.getMessage(e));
     }
     finally
     {
         m_attributeResultReportTable = facade.getActionResultMessages();
     }
 }
 
 public void testReadTimes() 
 {
     try
     {
         long totalOld = 0;
         long totalNew = 0;
         int LOOPS = 10;
         for ( int i = 0 ; i < LOOPS ; i ++ )
         {
             /*long beforeOld = System.currentTimeMillis ();
             if(m_initializedQuality && (m_ValueReader == null || !m_ValueReader.isAlive()))
             {
                 m_ValueReader = new ValueReader();
                 //m_ValueReader.start();
                 m_ValueReader.run();
             }
             long afterOld = System.currentTimeMillis ();
             long old = afterOld-beforeOld;       
             totalOld += old;*/
             
             long beforeNew = System.currentTimeMillis ();
             //Map<String, Double> states = tangoGroupForAttributes.readNumericAttributesSortedByAttribute();
             Map<String, Double> states = facade.getNumericAttributesSortedByAttribute();
             m_attributeValueTable = (Hashtable<String, Double>) states;
             long afterNew = System.currentTimeMillis ();
             long neww = afterNew-beforeNew;
             totalNew += neww;
         }
         
         System.out.println ( "CLA/testReadTimes/totalOld/"+totalOld+"/totalNew/"+totalNew );
     }
     catch (Throwable e)
     {
         e.printStackTrace ();
     }
 }
 /*
 private void traceAttributeValueTable ( String comment ) 
 {
     Iterator<String> it= m_attributeValueTable.keySet().iterator();
     System.out.println ( "traceAttributeValueTable "+comment + " VVVVVVV" );
     while ( it.hasNext () )
     {
         String nextAttribute = it.next ();
         Double nextVal = m_attributeValueTable.get ( nextAttribute );
         System.out.println ( "      nextAttribute|"+nextAttribute+"|nextVal|"+nextVal );
     }
     System.out.println ( "traceAttributeValueTable "+comment + " ^^^^^^^^" );
 }
 
 private void traceAttributeResultReportTable ( String comment ) 
 {
     Iterator<String> it= m_attributeResultReportTable.keySet().iterator();
     System.out.println ( "traceAttributeResultReportTable "+comment + " VVVVVVV" );
     while ( it.hasNext () )
     {
         String nextAttribute = it.next ();
         String nextVal = m_attributeResultReportTable.get ( nextAttribute );
         System.out.println ( "      nextAttribute|"+nextAttribute+"|nextVal|"+nextVal );
     }
     System.out.println ( "traceAttributeResultReportTable "+comment + " ^^^^^^^^" );
 }

 */

//  ===================================================================
    /**
     *  Method called by the write_attributes CORBA operation to
     *  write device hardware.
     *
     *  @param  attr_list   vector of index in the attribute vector
     *      of attribute to be written
     */
//  ===================================================================         
    public void write_attr_hardware(Vector attr_list)
    {
        Util.out2.println("In write_attr_hardware for "+attr_list.size()+" attribute(s)");
    
        for (int i=0 ; i<attr_list.size() ; i++)
        {
            WAttribute att = dev_attr.get_w_attr_by_ind(((Integer)(attr_list.elementAt(i))).intValue());
            String attr_name = att.get_name();
            
            //  Switch on attribute name
            //---------------------------------
            if (attr_name.equalsIgnoreCase("booleanResult"))
            {
                try
                {
                    if(att.get_bool_write_value())
                        activate_all();
                    else
                        deactivage_all();
                }
                catch (DevFailed e)
                {
                    e.printStackTrace ();
                }
            }
        }
    }
 
 //===================================================================
 /**
  * Method called by the read_attributes CORBA operation to set internal
  * attribute value.
  * 
  * @param attr reference to the Attribute object
  */
 //===================================================================
 public synchronized void read_attr(Attribute attr)throws DevFailed
 {
     String attr_name = attr.get_name();
     get_logger().info("In read_attr for attribute " + attr_name);
     
     //attr_spectrumResult_read update in ValueUpdater Thread
     if(attr_name == "spectrumResult")
         attr.set_value(attr_spectrumResult_read, attr_spectrumResult_read.length);
     
     //attr_attributesQualityList_read update in QualityReader Thread
     else if(attr_name == "attributesQualityList")
         attr.set_value(attr_attributesQualityList_read, attr_attributesQualityList_read.length);
     
     //attr_attributesNumberPriorityList_read update in QualityReader Thread
     else if(attr_name == "attributesNumberPriorityList")
         attr.set_value(attr_attributesNumberPriorityList_read, attr_attributesNumberPriorityList_read.length);
     
     //attr_booleanSpectrum_read update in QualityReader Thread
     else if(attr_name == "booleanSpectrum")
         attr.set_value(attr_booleanSpectrum_read, attr_booleanSpectrum_read.length);
     
     //m_booleanLogicalVector update in ValueUpdater Thread
     else if(attr_name == "booleanResult")
     {
         //m_booleanLogicalVector is update in the ValueUpdater thread
         //System.out.println("m_booleanLogicalVector.size()=" + m_booleanLogicalVector.size());
         boolean result = apply_logical_gate(m_booleanLogicalVector);
         attr.set_value(result);
     }
     
     else if (attr_name.equals("State"))
     {
         if(!m_initializedQuality)
         {
             attr.set_value(StateUtilities.getNameForState(DevState.FAULT));
             return;
         }
         attr.set_value(StateUtilities.getNameForState(get_state()));
     }
     
     else if (attr_name.equals("Status"))
     {
        attr.set_value(get_status());
     }
     
     //attr_attributesResultReport_read
     else if (attr_name == "attributesResultReport")
     {
         // Add your own code here
         //System.out.println("Read attributesResult m_attributeResultReportTable.size()" + m_attributeResultReportTable.size());
         attr_attributesResultReport_read = new String[m_attributeResultReportTable.size()];
         Iterator enumeration = m_attributeResultReportTable.keySet().iterator();
         int tmpIndex = 0;
         while(enumeration.hasNext())
         {
             String key = (String)enumeration.next();
             attr_attributesResultReport_read[tmpIndex]= key + "->" +(String)m_attributeResultReportTable.get(key);
             tmpIndex++;
         }
         attr.set_value(attr_attributesResultReport_read, attr_attributesResultReport_read.length);
     }
 }
 
 //=========================================================
 /**
  * Execute command "GetPriorityForQuality" on device.
  * This command return the priority for a given quality
  */
 //=========================================================
 public short get_priority_for_quality(String argin)throws DevFailed
 {
     short argout = 0;
     get_logger().info("Entering get_priority_for_state()");
     AttrQuality attrQualitytmp = QualityUtilities.getQualityForName(argin);
     argout = ((Integer)m_priorityTable.get(attrQualitytmp)).shortValue();
     get_logger().info("Exiting get_priority_for_state()");
     return argout;
 }

 //=========================================================
 /**
  * Execute command "GetTangoQualities" on device.
  * This command return the list of possibles qualities
  */
 //=========================================================
 public String[] get_tango_qualities()throws DevFailed
 {
     get_logger().info("Entering get_tango_states()");
     get_logger().info("Exiting get_tango_states()");
     return QualityUtilities.QUALITYIST;
 }
 
 //=========================================================
 /**
  * Execute command "GetAttributeNameForIndex" on device.
  * This command return the attribute of an associated index
  */
 //=========================================================
 public String get_attribute_name_for_index(short argin)throws DevFailed
 {
     get_logger().info("Entering get_attribute_name_for_index()");
     String argout = "Unknown Index";
     if(attributeNameList != null && argin > -1 && argin < attributeNameList.length)
         argout = attributeNameList[argin];
     get_logger().info("Exiting get_attribute_name_for_index()");
     return argout;
 }
 
//=========================================================
 /**
  * Execute command "GetLogicalChoices" on device.
  * This command return the list of possibles logical gates
  */
 //=========================================================
 public String[] get_logical_boolean()throws DevFailed
 {
     get_logger().info("Entering get_tango_states()");
     get_logger().info("Exiting get_tango_states()");
     return logicalChoices;
 }
 
//=========================================================
 /**
  * Execute command "SetAllValues" on device.
  * This command write the given value on all the attributes
  */
 //=========================================================
 public synchronized void set_all_values(double argin)throws DevFailed
 {
     get_logger().info("Entering set_all_values()");
     //m_sentValue = argin;
     //Do nothing if the device is in error
     if(!m_initializedQuality)
         return;
     
     facade.setNewNumericAttributesValue ( argin );
     facade.executeWriteNumericAttributesTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_values()");
 }
 
//=========================================================
 /**
  * Execute command "SetAllFormat" on device.
  * This command set the format property eg : %6.3f on all the attributes
  */
 //=========================================================
 public synchronized void set_all_format(String argin) throws DevFailed
 {
     get_logger().info("Entering set_all_format()");
     m_sentProperty = argin;
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getFormatModifier(m_sentProperty) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_format()");
 }

//=========================================================
 /**
  * Execute command "SetAllUnit" on device.
  * This command set the Unit property eg : Volt on all the attributes
  */
 //=========================================================
 public synchronized void set_all_unit(String argin) throws DevFailed
 {
     get_logger().info("Entering set_all_unit()");
     m_sentProperty = argin;
     
     facade.setModifierForSetAttributesInfoTask( AttributeInfoModifierFactory.getUnitModifier ( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_unit()");
 }

//=========================================================
 /**
  * Execute command "SetAllMinValue" on device.
  * This command set the minimum value property on all the attributes
  */
 //=========================================================
 public synchronized void set_all_min_value(double argin) throws DevFailed
 {
     get_logger().info("Entering set_all_min_value()");
     m_sentProperty = String.valueOf(argin);
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getMinValueModifier ( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_min_value()");
 }

//=========================================================
 /**
  * Execute command "SetAllMaxValue" on device.
  * This command set the maximum value property on all the attributes
  */
 //=========================================================
 public synchronized void set_all_max_value(double argin)throws DevFailed
 {
     get_logger().info("Entering set_all_max_value()");
     m_sentProperty = String.valueOf(argin);
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getMaxValueModifier( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_max_value()");
 }

//=========================================================
 /**
  * Execute command "SetAllMinAlarm" on device.
  * This command set the minimum alarm value property on all the attributes
  */
 //=========================================================
 public synchronized void set_all_min_alarm(double argin) throws DevFailed
 {
     get_logger().info("Entering set_all_min_alarm()");
     m_sentProperty = String.valueOf(argin);
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getMinAlarmModifier ( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_min_alarm()");
 }

//=========================================================
 /**
  * Execute command "SetAllMaxAlarm" on device.
  * This command set the maximum alarm value property on all the attributes
  */
 //=========================================================
 public synchronized void set_all_max_alarm(double argin)throws DevFailed
 {
     get_logger().info("Entering set_all_max_alarm()");
     m_sentProperty = String.valueOf(argin);
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getMaxAlarmModifier ( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_max_alarm()");
 }

//=========================================================
 /**
  * Execute command "SetAllLabel" on device.
  * This command set the Label property on all the attributes
  */
 //=========================================================
 public synchronized void set_all_label(String argin)throws DevFailed
 {
     get_logger().info("Entering set_all_label()");
     m_sentProperty = argin;
     
     facade.setModifierForSetAttributesInfoTask ( AttributeInfoModifierFactory.getLabelModifier ( m_sentProperty ) );
     facade.executeSetAttributesInfoTask ();
     m_attributeResultReportTable = facade.getActionResultMessages ();
     
     get_logger().info("Exiting set_all_label()");
 }
 
//=========================================================
 /**
  * Execute command "ActivateAll" on device.
  * This command write 1 or true on all the attributes
  */
 //=========================================================
 public void activate_all()throws DevFailed
 {
     get_logger().info("Entering reset()");
     set_all_values(1);
     get_logger().info("Exiting reset()");
 }
//=========================================================
 /**
  * Execute command "DeactivateAll" on device.
  * This command write 0 or false on all the attributes
  */
 //=========================================================
 public void deactivage_all() throws DevFailed
 {
     get_logger().info("Entering reset()");
     set_all_values(0);
     get_logger().info("Exiting reset()");
 }
//=========================================================
 
//=========================================================

 public class ValueReader extends Thread
 {
     public void run()
     {
	     if ( facade == null || ! AttributeComposer.this.m_initializedQuality )
         {
             return;
         }
         
         try
         {
             facade.executeReadNumericAttributesWithQualitiesTask ();
             m_attributeValueTable = facade.getNumericAttributesSortedByAttribute();
         }
         catch (Exception e)
         {
             m_initializedQuality = false;
             set_state(DevState.FAULT);
             set_status(m_insertformat.format(new Date()) + " : Fatal Error Execute and Init Command \n" + TangoExceptionUtilities.getMessage(e));
         }
         finally
         {
             m_attributeResultReportTable = facade.getActionResultMessages();
         }
     }
 }
 
 public class StateReader extends Thread
 {
     public void run()
     {
         if ( facade == null || ! AttributeComposer.this.m_initializedQuality )
         {
             return;
         }
         
         facade.executeReadNumericAttributesWithQualitiesTask();//refresh the qualities at the same time
         m_attributeQualityTable = facade.getNumericAttributeQualities();
         //traceAttributeToQualityTable ("NEW");
     }
 }
 /*
  * This Thread compute a resum state for the device
  */
 public class StateUpdater extends Thread
 {
     public void run()
     {
         if ( facade == null )
         {
             return;
         }
         
         try
         {
             //Hastable used to delete the double entry of quality <Quality,Priority>
             Hashtable<AttrQuality, Integer> tmpResumQualityTable = new Hashtable<AttrQuality, Integer>();
             //Hastable used to delete the double entry of priority <Priority,Quality>
             Hashtable <Integer, AttrQuality> tmpResumPriorityTable = new Hashtable<Integer, AttrQuality>();
           
             Iterator enumeration = m_attributeQualityTable.keySet().iterator();
             while(enumeration.hasNext())
             {
                String tmpAttributeName = (String)enumeration.next();
                AttrQuality attrQualityTmp = AttrQuality.ATTR_INVALID;
                if(m_attributeQualityTable.containsKey(tmpAttributeName))
                    attrQualityTmp = m_attributeQualityTable.get(tmpAttributeName).getAttrQuality();
                
                int tmpIndex = get_index_for_attribute(tmpAttributeName);
                if(tmpIndex != -1)
                {
                    attr_attributesNumberPriorityList_read[tmpIndex] = ((Integer)m_priorityTable.get(attrQualityTmp)).shortValue();
                    attr_attributesQualityList_read[tmpIndex] = QualityUtilities.getNameForQuality(attrQualityTmp) + "-" + attributeNameList[tmpIndex];
                    // delete the double entry for a quality
                    if(!tmpResumQualityTable.containsKey(attrQualityTmp) && !tmpResumQualityTable.contains((Integer)m_priorityTable.get(attrQualityTmp)))
                        tmpResumQualityTable.put(attrQualityTmp, (Integer)m_priorityTable.get(attrQualityTmp));
                }
             }
             
             //If the device is in error dont compute the resum state
             if(!m_initializedQuality)
             {
                 //System.out.println("m_initialized=" + m_initialized);
                 tmpResumQualityTable.clear();
                 return;
             }
         
             //System.out.println("tmpResumQualityTable=" + tmpResumQualityTable.size());
             //Compute the state of device
             if(tmpResumQualityTable.size() == 0)
                 return;
             
             else if(tmpResumQualityTable.size() == 1)
             {
                 AttrQuality tmpAttributeQuality = (AttrQuality)tmpResumQualityTable.keys().nextElement();
                 set_state((DevState)m_qualityStateTable.get(tmpAttributeQuality));
                 set_status("All the attributes are in " + QualityUtilities.getNameForQuality(tmpAttributeQuality) + " quality.");
             }
             // Check the prority of qualities
             else
             {
                 AttrQuality tmpAttributeQuality;
                 Integer tmpPriority;
                 for(Enumeration enumeration2 = tmpResumQualityTable.keys(); enumeration2.hasMoreElements(); tmpResumPriorityTable.put(tmpPriority, tmpAttributeQuality))
                 {
                     tmpAttributeQuality = (AttrQuality)enumeration2.nextElement();
                     tmpPriority = (Integer)tmpResumQualityTable.get(tmpAttributeQuality);
                 }
                 //Sort the quality by priority 
                 Object objList[] = tmpResumQualityTable.values().toArray();
                 Arrays.sort(objList);
                 //get the greatest priority
                 tmpAttributeQuality = (AttrQuality)tmpResumPriorityTable.get(objList[objList.length - 1]);
                 DevState tmpDeviceState = (DevState)m_qualityStateTable.get(tmpAttributeQuality);
                 set_state(tmpDeviceState);
                 set_status("One of the attribute is in " + QualityUtilities.getNameForQuality(tmpAttributeQuality) + " quality.");
             }
             
             //Clear the table
             tmpResumQualityTable.clear();
             tmpResumPriorityTable.clear();
         }
         catch(Exception e)
         {
             //exception.printStackTrace();
             m_initializedQuality = false;
             set_state(DevState.FAULT);
             set_status(m_insertformat.format(new Date()) + " : Unexpected Error, cannot compute a resum State for the device\n" + TangoExceptionUtilities.getMessage(e));
             return;
         }
     }
 }
 //=========================================================
 
//=========================================================
 /*
  * This Thread update all the spectrum attribute
  */
 public class ValueUpdater extends Thread
 {
     public void run()
     {
         if ( facade == null )
         {
             return;
         }
         
         //System.out.println("ValueUpdater"); 
         String tmpAttributeName = "";
         try
         {
             Iterator enumeration = m_attributeValueTable.keySet().iterator();
             //Apply the logical gates on attr_booleanSpectrum_read
             m_booleanLogicalVector.clear();
             while (enumeration.hasNext())
             {
                tmpAttributeName = (String) enumeration.next();
                double tmpReadValue = ((Double)m_attributeValueTable.get(tmpAttributeName)).doubleValue();
                short tmpBooleanShortValue = 0;
                Boolean tmpBooleanValue = Boolean.FALSE;
                int tmpIndex = get_index_for_attribute(tmpAttributeName);
                if(tmpReadValue == 1)
                {
                    tmpBooleanShortValue = 1;
                    tmpBooleanValue = Boolean.TRUE;
                }
                attr_spectrumResult_read[tmpIndex] = tmpReadValue;
                attr_booleanSpectrum_read[tmpIndex] = tmpBooleanShortValue;
                if(!m_booleanLogicalVector.contains(tmpBooleanValue))
                    m_booleanLogicalVector.add(tmpBooleanValue);
            }
         }
         catch(Exception e)
         {
             //m_initializedValue = false;
             set_state(DevState.FAULT);
             set_status(m_insertformat.format(new Date()) + " : Unexpected Error, cannot read " + tmpAttributeName + " relaunch the necessary attributes and make and Init Command : \n" + TangoExceptionUtilities.getMessage(e));
             return;
         }
     }
 }
//=========================================================
 public static void main(String argv[])
 {
     System.out.println("ATTRIBUTECOMPOSER VERSION 3.0.2");
     
     try
     {
        //Unexport the server before
        if(argv != null && argv.length > 0)
        {
            new Database().unexport_server("attributecomposer/" + argv[0]);
        }
     }
     catch(Exception e){}
     
     try
     {
         
         Util tg = Util.init(argv, "AttributeComposer");
         tg.server_init();
         System.out.println("Ready to accept request");
         tg.server_run();
     }
     catch(OutOfMemoryError ex)
     {
         System.err.println("Can't allocate memory !!!!");
         System.err.println("Exiting");
     }
     catch(UserException ex)
     {
         Except.print_exception(ex);
         System.err.println("Received a CORBA user exception");
         System.err.println("Exiting");
     }
     catch(SystemException ex)
     {
         Except.print_exception(ex);
         System.err.println("Received a CORBA system exception");
         System.err.println("Exiting");
     }
     System.exit(-1);
 }
 
}
